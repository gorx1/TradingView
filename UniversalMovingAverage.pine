//@version=6
indicator('Universal Moving Average', 'UMA', true, timeframe = '', timeframe_gaps = true)
//by gorx1


//  dependencies........................................................................................................
mean(array<float> data, array<float> weights, int len) =>
    sum = 0.

    for i = 0 to len - 1
        sum += data.get(i) * weights.get(i)


    array.new<float>(len, sum / weights.sum())
//  dependencies........................................................................................................


//  data interval logic.................................................................................................
anchor = input.string('Moving window', 'anchor',
 ['1', '5', '24h', 'Session', 'Year', 'Cumulative', 'Moving window', 'Custom session'], group = 'interval')

length  = input        (256        , 'moving window length' , group = 'interval')
session = input.session('0000-2345', 'custom session period', group = 'interval')
hybrid  = input        (false      , 'hybrid window'        , group = 'interval')

isNewPeriod = switch anchor
    '1'       => timeframe.change('1'   )
    '5'       => timeframe.change('5'   )
    '24h'     => timeframe.change('1440')
	'Session' => timeframe.change('D'   )
	'Year'    => timeframe.change('12M' )

if na(close[1])
	isNewPeriod := true

var barsInSession = 0
barsInSession    := isNewPeriod ? 1 : 1 + barsInSession

var barsInSessionCustom = 0
barsInSessionCustom    := na(time('', session)) ? 1 : 1 + barsInSessionCustom

len = if anchor == 'Cumulative'
    bar_index + 1
else  if anchor == 'Moving window'
    length
else  if anchor == 'Custom session'
    barsInSessionCustom
else
    barsInSession + (hybrid ? length : 0)

len := len > bar_index + 1 ? bar_index + 1 : len
//  data interval logic.................................................................................................


//  main................................................................................................................
src = input(hl2, 'Source')

space  = input(false, 'Price'          , inline = '1', group = 'Weighting by:')
time_  = input(true , 'Time'           , inline = '1', group = 'Weighting by:')
force  = input(true , 'Inferred volume', inline = '1', group = 'Weighting by:')
signal = input(true , 'Signal'         , inline = '1', group = 'Weighting by:')
state  = input(true , 'State'          , inline = '1', group = 'Weighting by:')


data    = array.new_float(len)
weights = array.new_float(len)

for i = 0 to len - 1
    w_space = space ?    hl2[i]                                                  : 1             //  encodes datum location in price  field
    w_time  = time_ ? (len - i)                                                  : 1             //  encodes datum location in time   field
    w_force = force ? (256 * math.abs(close[i] - open[i]) / syminfo.mintick + 1) : 1             //  encodes datum location in volume field

    w_pdf = signal ? (i / (len - 1)) * (1 - i / (len - 1))                                   : 1 //  beta(2, 2) PDF aka Welch window     , both encode actuality/importance/revelance
    w_cdf = signal ? (1 - (3 * math.pow(i / (len - 1), 2) - 2 * math.pow(i / (len - 1), 3))) : 1 //  beta(2, 2) inverted CDF aka survival, both encode actuality/importance/revelance 

    w_state = state ? math.pow(src[i] - src[i + 1], 2) : 1                                       //  quad returns are natural for encoding state space innovation info, unlike abs returns 


    data   .set(i, src[i]                                              )
    weights.set(i, w_space * w_time * w_force * w_pdf * w_cdf * w_state)


uma = mean(data, weights, len).get(0)
//  main................................................................................................................


//  visuals.............................................................................................................
viz_off = input(1, 'plotting offset', group = 'style') //  always 1 for objective analysis, latest datapoint self inclusion is should Not be done

color_uma = uma > uma[1] ? color.blue : uma < uma[1] ? color.red : color.purple

plot(uma, 'uma', color_uma, 2, plot.style_steplinebr, offset = viz_off)
//  visuals.............................................................................................................


//  âˆž
