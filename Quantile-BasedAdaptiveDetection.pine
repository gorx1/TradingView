//@version=6
indicator('Quantile-Based Adaptive Detection', 'QBAD', true, precision = 4, timeframe ='', timeframe_gaps = true)
//by gorx1


//  dependencies........................................................................................................
multisort(array_base, array_second, reverse = false) =>
    len = array_base.size()

    sorted_indices      = array.sort_indices(array_base, reverse ? order.descending : order.ascending)
    sorted_array_base   = array.new_float(len)
    sorted_array_second = array.new_float(len)
    
    for i = 0 to len - 1
        idx = sorted_indices.get(i)
        
        sorted_array_base  .set(i, array_base  .get(idx))
        sorted_array_second.set(i, array_second.get(idx))
    

    [sorted_array_base, sorted_array_second]


wpnr(data, weights, len, p) =>
    [sorted_data, sorted_weights] = multisort(data, weights)
    
    sorted_weights_cum = array.new_float(len, sorted_weights.get(0))

    if len > 1
        for i = 1 to len - 1
            sorted_weights_cum.set(i, sorted_weights_cum.get(i - 1) + sorted_weights.get(i))
    
    wpnr  = 0.0
    thres = sorted_weights.sum() / 100 * p

    for i = 0 to len - 1
        if sorted_weights_cum.get(i) >= thres
            wpnr := sorted_data.get(i)
            break
    

    wpnr


median(data, weights, len) =>
    array.new<float>(len, wpnr(data, weights, len, 50))


quantile_moments(data, weights, center, len) => //not optimized but explicit so you can realize what it really is faster
    residuals = array.new_float(len, 0)

    for [i, v] in data
        residuals.set(i, data.get(i) - center.get(i))

    [sorted_residuals, sorted_weights] = multisort(residuals, weights)
    sorted_weights_sum                 = sorted_weights.sum()

    
    threshold_lower_hkurt = sorted_weights_sum * (    1 / 64)
    threshold_lower_hskew = sorted_weights_sum * (    1 / 32)
    threshold_lower_kurt  = sorted_weights_sum * (    1 / 16)
    threshold_lower_skew  = sorted_weights_sum * (    1 / 8 )
    threshold_lower_dev   = sorted_weights_sum * (    1 / 4 )
    threshold_lower_bias  = sorted_weights_sum * (    1 / 2 )
    threshold_lower_init  = sorted_weights_sum * (    1 / 1 )
        
    threshold_upper_init  = sorted_weights_sum * (1 - 1 / 1 )
    threshold_upper_bias  = sorted_weights_sum * (1 - 1 / 2 )
    threshold_upper_dev   = sorted_weights_sum * (1 - 1 / 4 )
    threshold_upper_skew  = sorted_weights_sum * (1 - 1 / 8 )
    threshold_upper_kurt  = sorted_weights_sum * (1 - 1 / 16)
    threshold_upper_hskew = sorted_weights_sum * (1 - 1 / 32)
    threshold_upper_hkurt = sorted_weights_sum * (1 - 1 / 64)
    

    float quantile_lower_hkurt = na
    float quantile_lower_hskew = na
    float quantile_lower_kurt  = na
    float quantile_lower_skew  = na
    float quantile_lower_dev   = na
    float quantile_lower_bias  = na
    float quantile_lower_init  = na
    
    float quantile_upper_init  = na
    float quantile_upper_bias  = na
    float quantile_upper_dev   = na
    float quantile_upper_skew  = na
    float quantile_upper_kurt  = na
    float quantile_upper_hskew = na
    float quantile_upper_hkurt = na


    sorted_weights_cum = 0.

    for i = 0 to len - 1
        sorted_weights_cum += sorted_weights  .get(i)  
        sorted_residual     = sorted_residuals.get(i)

        if na(quantile_lower_hkurt) and sorted_weights_cum >= threshold_lower_hkurt
            quantile_lower_hkurt := sorted_residual
        if na(quantile_lower_hskew) and sorted_weights_cum >= threshold_lower_hskew
            quantile_lower_hskew := sorted_residual
        if na(quantile_lower_kurt ) and sorted_weights_cum >= threshold_lower_kurt
            quantile_lower_kurt  := sorted_residual
        if na(quantile_lower_skew ) and sorted_weights_cum >= threshold_lower_skew
            quantile_lower_skew  := sorted_residual
        if na(quantile_lower_dev  ) and sorted_weights_cum >= threshold_lower_dev
            quantile_lower_dev   := sorted_residual
        if na(quantile_lower_bias ) and sorted_weights_cum >= threshold_lower_bias
            quantile_lower_bias  := sorted_residual
        if na(quantile_lower_init ) and sorted_weights_cum >= threshold_lower_init
            quantile_lower_init  := sorted_residual

        if na(quantile_upper_init ) and sorted_weights_cum >= threshold_upper_init
            quantile_upper_init  := sorted_residual
        if na(quantile_upper_bias ) and sorted_weights_cum >= threshold_upper_bias
            quantile_upper_bias  := sorted_residual
        if na(quantile_upper_dev  ) and sorted_weights_cum >= threshold_upper_dev
            quantile_upper_dev   := sorted_residual
        if na(quantile_upper_skew ) and sorted_weights_cum >= threshold_upper_skew
            quantile_upper_skew  := sorted_residual
        if na(quantile_upper_kurt ) and sorted_weights_cum >= threshold_upper_kurt
            quantile_upper_kurt  := sorted_residual
        if na(quantile_upper_hskew) and sorted_weights_cum >= threshold_upper_hskew
            quantile_upper_hskew := sorted_residual
        if na(quantile_upper_hkurt) and sorted_weights_cum >= threshold_upper_hkurt
            quantile_upper_hkurt := sorted_residual

        if not na(quantile_upper_hkurt)
            break


    m0 = (quantile_upper_init  - quantile_lower_init ) / 2
    m1 = (quantile_upper_bias  + quantile_lower_bias ) / 2
    m2 = (quantile_upper_dev   - quantile_lower_dev  ) / 2  
    m3 = (quantile_upper_skew  + quantile_lower_skew ) / 2
    m4 = (quantile_upper_kurt  - quantile_lower_kurt ) / 2
    m5 = (quantile_upper_hskew + quantile_lower_hskew) / 2
    m6 = (quantile_upper_hkurt - quantile_lower_hkurt) / 2

 
    init = m0 / m0

    bias = m1
    dev  = m2

    skew  = m3 / dev
    kurt  = m4 / dev
    hskew = m5 / dev
    hkurt = m6 / dev


    moments = array.new_float(7)

    moments.set(0,  init)
    moments.set(1,  bias)
    moments.set(2,   dev)
    moments.set(3,  skew)
    moments.set(4,  kurt)
    moments.set(5, hskew)
    moments.set(6, hkurt)


    moments


type distro
    float low_lim
    float low_ext
    float low_dev
    float basis
    float upp_dev
    float upp_ext
    float upp_lim
    float dev
    float asym


qbad(data_y, weights, len) =>
    fit     = median          (data_y, weights,      len)
    moments = quantile_moments(data_y, weights, fit, len)
    center  = fit.get(0)

    init  = moments.get(0)
    bias  = moments.get(1)
    dev   = moments.get(2)
    skew  = moments.get(3)
    kurt  = moments.get(4)
    hskew = moments.get(5)
    hkurt = moments.get(6)

    
    out = distro.new()

    out.basis   := center                      
    out.low_dev := center      - (dev - bias)                      
    out.upp_dev := center      + (dev + bias)                      
    out.low_ext := out.low_dev - (dev - bias) * ( kurt -  skew)
    out.upp_ext := out.upp_dev + (dev + bias) * ( kurt +  skew)
    out.low_lim := out.low_ext - (dev - bias) * (hkurt - hskew)
    out.upp_lim := out.upp_ext + (dev + bias) * (hkurt + hskew)

    out.dev := dev    

    out.asym := ((skew / kurt) - (hskew / hkurt)) * dev * 2
    

    out


interval_check(data, weights, lower, upper, len) =>
    sum   = 0.
    sum_w = 0.

    for i = 0 to len - 1 
        v      = data   .get(i)
        w      = weights.get(i)

        sum   += (v >= lower and v <= upper ? 1 : 0) * w
        sum_w += w


    sum / sum_w
//  dependencies........................................................................................................


//  data interval logic.................................................................................................
anchor  = input.string('Session', 'anchor',
 ['1', '5', '24h', 'Session', 'Year', 'Cumulative', 'Moving window', 'Custom session'], group = 'interval')

length  = input        (256        , 'moving window length' , group = 'interval')
session = input.session('0000-2345', 'custom session period', group = 'interval')
hybrid  = input        (false      , 'hybrid window'        , group = 'interval')

isNewPeriod = switch anchor
    '1'       => timeframe.change('1'   )
    '5'       => timeframe.change('5'   )
    '24h'     => timeframe.change('1440')
	'Session' => timeframe.change('D'   )
	'Year'    => timeframe.change('12M' )

if na(close[1])
	isNewPeriod := true

var barsInSession = 0
barsInSession    := isNewPeriod ? 1 : 1 + barsInSession

var barsInSessionCustom = 0
barsInSessionCustom    := na(time('', session)) ? 1 : 1 + barsInSessionCustom

len = if anchor == 'Cumulative'
    bar_index + 1
else  if anchor == 'Moving window'
    length
else  if anchor == 'Custom session'
    barsInSessionCustom
else
    barsInSession + (hybrid ? length : 0)

len := len > bar_index + 1 ? bar_index + 1 : len
//  data interval logic.................................................................................................


//  main................................................................................................................
src   = input(hlc3, 'Source'                                                      )
time_ = input(true, 'Sequence'             , inline = '1', group = 'Weighting by:')
force = input(true, 'Inferred volume delta', inline = '1', group = 'Weighting by:')


data    = array.new_float(len)
weights = array.new_float(len)

for i = 0 to len - 1
    weight = (time_ ? (len - i) : 1) * (force ? 256 * math.abs(close[i] - open[i]) / syminfo.mintick + 1 : 1)

    data   .set(i, src[i])
    weights.set(i, weight)


distro_data = qbad(data, weights, len)

prop = interval_check(data, weights, distro_data.low_dev, distro_data.upp_dev, len) //  proportion of data inside value
//  main................................................................................................................


//  visuals.............................................................................................................
viz_off = input(1, 'plotting offset', group = 'style') //always 1 for objective analysis, latest datapoint self inclusion is should Not be done

plot(distro_data.low_lim, 'lower limit'    , color.red   , 1, plot.style_steplinebr, offset = viz_off)
plot(distro_data.low_ext, 'lower extension', color.red   , 1, plot.style_steplinebr, offset = viz_off)
plot(distro_data.low_dev, 'lower deviation', color.purple, 1, plot.style_steplinebr, offset = viz_off)
plot(distro_data.basis  , 'basis'          , color.purple, 1, plot.style_steplinebr, offset = viz_off)
plot(distro_data.upp_dev, 'upper deviation', color.purple, 1, plot.style_steplinebr, offset = viz_off)
plot(distro_data.upp_ext, 'upper extension', color.blue  , 1, plot.style_steplinebr, offset = viz_off)
plot(distro_data.upp_lim, 'upper limit'    , color.blue  , 1, plot.style_steplinebr, offset = viz_off)

plot(na, 'space', color.gray)

plot(prop, 'proportion of data inside value', color.gray)
//  visuals.............................................................................................................


//  âˆž
