//@version=6
indicator('Quantile-Based Adaptive Detection', 'QBAD', true, precision = 4, timeframe ='', timeframe_gaps = true)



//dependencies..........................................................................................................
multisort(array_base, array_second, reverse = false) =>
    len = array_base.size()

    sorted_indices      = array.sort_indices(array_base, reverse ? order.descending : order.ascending)
    sorted_array_base   = array.new_float(len)
    sorted_array_second = array.new_float(len)
    
    for i = 0 to len - 1
        idx = sorted_indices.get(i)
        
        sorted_array_base  .set(i, array_base  .get(idx))
        sorted_array_second.set(i, array_second.get(idx))
    

    [sorted_array_base, sorted_array_second]


wpnr(data, weights, len, p) =>
    [sorted_data, sorted_weights] = multisort(data, weights)
    
    sorted_weights_cum = array.new_float(len, sorted_weights.get(0))

    if len > 1
        for i = 1 to len - 1
            sorted_weights_cum.set(i, sorted_weights_cum.get(i - 1) + sorted_weights.get(i))
    
    wpnr  = 0.0
    thres = sorted_weights.sum() / 100 * p

    for i = 0 to len - 1
        if sorted_weights_cum.get(i) >= thres
            wpnr := sorted_data.get(i)
            break
    
    wpnr


quantile_moments(data, weights, center, len) => //not optimized but explicit so you can realize what it really is faster
    residuals = array.new_float(len, 0)

    for [i, v] in data
        residuals.set(i, data.get(i) - center)

    [sorted_residuals, sorted_weights] = multisort(residuals, weights)
    sorted_weights_sum                 = sorted_weights.sum()

    
    threshold_lower_hkurt = sorted_weights_sum * (    1 / 64)
    threshold_lower_hskew = sorted_weights_sum * (    1 / 32)
    threshold_lower_kurt  = sorted_weights_sum * (    1 / 16)
    threshold_lower_skew  = sorted_weights_sum * (    1 / 8 )
    threshold_lower_dev   = sorted_weights_sum * (    1 / 4 )
    threshold_lower_bias  = sorted_weights_sum * (    1 / 2 )
    threshold_lower_init  = sorted_weights_sum * (    1 / 1 )
        
    threshold_upper_init  = sorted_weights_sum * (1 - 1 / 1 )
    threshold_upper_bias  = sorted_weights_sum * (1 - 1 / 2 )
    threshold_upper_dev   = sorted_weights_sum * (1 - 1 / 4 )
    threshold_upper_skew  = sorted_weights_sum * (1 - 1 / 8 )
    threshold_upper_kurt  = sorted_weights_sum * (1 - 1 / 16)
    threshold_upper_hskew = sorted_weights_sum * (1 - 1 / 32)
    threshold_upper_hkurt = sorted_weights_sum * (1 - 1 / 64)
    

    float quantile_lower_hkurt  = na
    float quantile_lower_hskew  = na
    float quantile_lower_kurt   = na
    float quantile_lower_skew   = na
    float quantile_lower_dev    = na
    float quantile_lower_bias   = na
    float quantile_lower_init   = na
    
    float quantile_upper_init  = na
    float quantile_upper_bias  = na
    float quantile_upper_dev   = na
    float quantile_upper_skew  = na
    float quantile_upper_kurt  = na
    float quantile_upper_hskew = na
    float quantile_upper_hkurt = na


    sorted_weights_cum = 0.

    for i = 0 to len - 1
        sorted_weights_cum += sorted_weights  .get(i)  
        sorted_residual     = sorted_residuals.get(i)

        if na(quantile_lower_hkurt) and sorted_weights_cum >= threshold_lower_hkurt
            quantile_lower_hkurt := sorted_residual
        if na(quantile_lower_hskew) and sorted_weights_cum >= threshold_lower_hskew
            quantile_lower_hskew := sorted_residual
        if na(quantile_lower_kurt ) and sorted_weights_cum >= threshold_lower_kurt
            quantile_lower_kurt  := sorted_residual
        if na(quantile_lower_skew ) and sorted_weights_cum >= threshold_lower_skew
            quantile_lower_skew  := sorted_residual
        if na(quantile_lower_dev  ) and sorted_weights_cum >= threshold_lower_dev
            quantile_lower_dev   := sorted_residual
        if na(quantile_lower_bias ) and sorted_weights_cum >= threshold_lower_bias
            quantile_lower_bias  := sorted_residual
        if na(quantile_lower_init ) and sorted_weights_cum >= threshold_lower_init
            quantile_lower_init  := sorted_residual

        if na(quantile_upper_init ) and sorted_weights_cum >= threshold_upper_init
            quantile_upper_init  := sorted_residual
        if na(quantile_upper_bias ) and sorted_weights_cum >= threshold_upper_bias
            quantile_upper_bias  := sorted_residual
        if na(quantile_upper_dev  ) and sorted_weights_cum >= threshold_upper_dev
            quantile_upper_dev   := sorted_residual
        if na(quantile_upper_skew ) and sorted_weights_cum >= threshold_upper_skew
            quantile_upper_skew  := sorted_residual
        if na(quantile_upper_kurt ) and sorted_weights_cum >= threshold_upper_kurt
            quantile_upper_kurt  := sorted_residual
        if na(quantile_upper_hskew) and sorted_weights_cum >= threshold_upper_hskew
            quantile_upper_hskew := sorted_residual
        if na(quantile_upper_hkurt) and sorted_weights_cum >= threshold_upper_hkurt
            quantile_upper_hkurt := sorted_residual

        if not na(quantile_upper_hkurt)
            break


    m0 = (quantile_upper_init  - quantile_lower_init ) / 2
    m1 = (quantile_upper_bias  + quantile_lower_bias ) / 2
    m2 = (quantile_upper_dev   - quantile_lower_dev  ) / 2  
    m3 = (quantile_upper_skew  + quantile_lower_skew ) / 2
    m4 = (quantile_upper_kurt  - quantile_lower_kurt ) / 2
    m5 = (quantile_upper_hskew + quantile_lower_hskew) / 2
    m6 = (quantile_upper_hkurt - quantile_lower_hkurt) / 2

 
    init = m0 / m0

    bias = m1
    dev  = m2

    skew  = m3 / dev
    kurt  = m4 / dev
    hskew = m5 / dev
    hkurt = m6 / dev

    [bias, dev, skew, kurt, hskew, hkurt]


qbad(data, weights, len) =>
    center                                = wpnr            (data, weights,         len, 50)
    [bias, dev, skew, kurt, hskew, hkurt] = quantile_moments(data, weights, center, len    )

    basis     = center                      
    dev_lower = basis     - (dev - bias)                      
    dev_upper = basis     + (dev + bias)                      
    ext_lower = dev_lower - (dev - bias) * ( kurt -  skew)
    ext_upper = dev_upper + (dev + bias) * ( kurt +  skew)
    lim_lower = ext_lower - (dev - bias) * (hkurt - hskew)
    lim_upper = ext_upper + (dev + bias) * (hkurt + hskew)

    asym = nz(((skew / kurt) - (hskew / hkurt)) * dev * 2)

    [lim_lower, ext_lower, dev_lower, basis, dev_upper, ext_upper, lim_upper, dev, asym]
//dependencies..........................................................................................................


//inputs................................................................................................................
src   = input(close, 'Source'                                                      )
len   = input(256  , 'Length'                                                      )
time_ = input(true , 'Sequence'             , inline = '1', group = 'Weighting by:')
force = input(true , 'Inferred volume delta', inline = '1', group = 'Weighting by:')
//inputs................................................................................................................


//data..................................................................................................................
data    = array.new_float(len)
weights = array.new_float(len)

for i = 0 to len - 1
    weight = (time_ ? (len - i) : 1) * (force ? math.abs(close[i] - open[i]) / syminfo.mintick : 1)

    data   .set(i, src[i])
    weights.set(i, weight)
//data..................................................................................................................


//calculations..........................................................................................................
[lim_lower, ext_lower, dev_lower, basis, dev_upper, ext_upper, lim_upper, dev, asym] = qbad(data, weights, len)
//calculations..........................................................................................................


//visuals...............................................................................................................
plot(lim_lower, 'lower limit'    , color.red   , 1, plot.style_stepline)
plot(ext_lower, 'lower extension', color.blue  , 2, plot.style_stepline)
plot(dev_lower, 'lower deviation', color.gray  , 1, plot.style_stepline)
plot(basis    , 'basis'          , color.purple, 2, plot.style_stepline)
plot(dev_upper, 'upper deviation', color.gray  , 1, plot.style_stepline)
plot(ext_upper, 'upper extension', color.red   , 2, plot.style_stepline)
plot(lim_upper, 'upper limit'    , color.blue  , 1, plot.style_stepline)
//visuals...............................................................................................................
// âˆž by gorx1
